import hashlib
from typing import Dict, List, Optional

# For Python < 3.8, TypedDict is in typing_extensions
try:
    from typing import TypedDict
except ImportError:
    from typing_extensions import TypedDict


class SourceInfo(TypedDict):
    """Structure for storing information about a cited source chunk."""
    dashboard: str
    original_index: int
    text_snippet: str


class CitationTracker:
    def __init__(self):
        """Initializes the CitationTracker.

        The tracker stores a map of chunk hashes to their source information.
        Each chunk hash maps to a `SourceInfo` dictionary.
        """
        self.source_map: Dict[str, SourceInfo] = {}

    def add_chunk(self, chunk, dashboard_id, chunk_idx):
        chunk_hash = hashlib.sha256(chunk.encode('utf-8')).hexdigest() # Specify encoding
        if chunk_hash not in self.source_map: # Avoid duplicates
            self.source_map[chunk_hash] = {
                'dashboard': dashboard_id,
                'original_index': chunk_idx,
                'text_snippet': chunk[:150] + "..." if len(chunk) > 150 else chunk
            }

    def get_citation_info(self, chunk_hash: str) -> Optional[SourceInfo]:
        return self.source_map.get(chunk_hash)
 
def format_response_with_citations(response_text, citation_hashes, tracker):
    citations = [tracker.source_map[h] for h in citation_hashes]
    citation_str = "\n\nSources:\n" + "\n".join(
        f"[{i+1}] {c['dashboard']} (Chunk {c['original_index']}): {c['text_snippet']}"
        for i, c in enumerate(citations)
    )
    return response_text + citation_str

def format_response_with_citations_ui(response_text: str, citation_hashes: List[str], tracker: CitationTracker) -> str:
    """
    Formats an LLM response string to include source citations for UI display.
    Args:
        response_text: The text generated by the LLM.
        citation_hashes: A list of chunk hashes that were sources for this response.
        tracker: The CitationTracker instance holding the source map.
    Returns:
        A string combining the response and its formatted citations, suitable for Markdown.
    """
    if not citation_hashes or not tracker or not tracker.source_map:
        return response_text # Return original if no hashes or tracker is not ready

    citations_found = []
    for h in citation_hashes:
        if h in tracker.source_map:
            citations_found.append(tracker.source_map[h])
        # else:
            # Optionally log if a hash wasn't found in the tracker
            # print(f"Warning: Chunk hash {h} not found in CitationTracker.")

    if not citations_found:
        return response_text

    # Sort citations by dashboard then by original_index for consistent ordering
    citations_found.sort(key=lambda c: (c['dashboard'], c['original_index']))
    
    citation_str_parts = ["\n\n**Sources:**"]
    for i, c_info in enumerate(citations_found):
        citation_str_parts.append(
            f"- Source {i+1}: Document '{c_info['dashboard']}', Chunk {c_info['original_index']} (Snippet: \"{c_info['text_snippet']}\")"
        )
    
    return response_text + "\n" + "\n".join(citation_str_parts)
